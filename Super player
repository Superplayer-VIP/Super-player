	导入“ ./Pausable.sol”；
	

echo "bitcoin hard nofile 65536" >> /etc/security/limits.conf
 echo "bitcoin soft nofile 65536" >> /etc/security/limits.conf

＃用于运行守护程序的用户名
用户名=
＃ 主机名。将其设置为FQDN，以便从外部访问
主机=本地主机
＃个端口

	         
	        地址刻录机= msg.sender;
	        balances[burner] = balances[burner].sub(_value)
	        Burn(burner, _value);
	    }
	}
	

	

	  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
	    return super.transfer(_to, _value);
	  }
	

	    return super.transferFrom(_from, _to, _value);
	  }
	

	  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
	  }
	  }
	

	  }
	}
	

	contract SPC Token is PausableToken, BurnableToken {
	

	    string public constant name = "SPC Token";	    address public deductTicketAccount; 

	    uint8  public constant decimals = 18;
	    uint256 public constant INITIAL_SUPPLY = 340000000 * 10**uint256(decimals)
	    address public withDrawAccount;
	

	    function SPCToken() public 
	    {
	        totalSupply = INITIAL_SUPPLY;   
	        balances[msg.sender] = INITIAL_SUPPLY; 
	        withDrawAccount = msg.sender;
	        deductTicketAccount = ms

verocoin_rpc_port = 8000
stratum_tcp_port = 50001
#stratum_tcp_ssl_port = 50002
#report_host =
#report_stratum_tcp_port = 50001
#report_stratum_tcp_ssl_port = 50002
横幅=欢迎使用Verocoin！
banner_file = /etc/verocoin.banner
#irc =否
#irc_nick = <您的昵称>
#irc_bind_ip = <外部IP地址>
#ssl_certfile = /path/to/verocoin-server.crt
#ssl_keyfile = /path/to/verocoin-server.key
日志文件= /var/log/verocoin.log
donation_address =

[leveldb]
＃数据库的路径
路径=
＃对于每个地址，如果历史记录长于此限制，则将对其进行修剪
pruning_limit = 100

＃缓存大小（以字节为单位），默认值已针对约4 GB RAM设置进行了优化，以与bitcoind一起运行
＃如果您有大量RAM，请增加16倍以获得最佳性能
#hist_cache = 67108864
#utxo_cache = 134217728
#addr_cache = 16777216

echo "session required pam_limits.so" >> /etc/pam.d/common-session-noninteractive	        if（isNotVIP1（a））
	        {
	            返回0;
	        }
	        否则if（isNotVIP2（a））
	        {
	            返回1;
	        }
	        否则if（isNotVIP3（a））
	        {
	            返回2;
	        }
	        否则if（isNotVIP4（a））
	        {
	            返回3;
	        }
	        其他
	        {
	            返回4;
	        }
	    }  
	    
	    函数getMyInviteAddress（）查看公共退货（地址）
	    {
	        uint256 myid = addressToIdMap [msg.sender]; 
	        
	        if（myid！= 0）
	        {
	            播放器存储空间p = idToPlayerMap [myid];
	            返回idToPlayerMap [p.inviteId] .account;
	        }
	        
	        返回0;
	    }  
	    
	    函数getMyAmbassadorIncome（）查看公共收益（uint256）
	    {
	        播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];
	       返回p.incomeDetail [8];
	    }
	    
	    
	    函数getMyTotalBuyAmt（）查看公共退货（uint256）
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];
	       返回p.totalPay;
	    }
	    
	    函数getMyVIPIncome（）查看公共退货（uint256）
	    {
	         播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];
	         
	         返回p.incomeDetail [4] + p.incomeDetail [5] + p.incomeDetail [6] + p.incomeDetail [7];
	    }
	    
	                    } 
	                }
	                否则if（addressToPay（a）<= 30以太币）
	                {
	                    if（addressToPay（a）* 4 * 97/100> getAllIncomeByAddress（a））
	                    {
	                        返回addressToPay（a）* 4 * 97/100-getAllIncomeByAddress（a）;
	                    }
	                    其他
	                    {
	                        返回0;
	                    }
	                    
	                }
	                否则if（addressToPay（a）> 30 ether）
	                {
	                    if（addressToPay（a）* 5 * 97/100> getAllIncomeByAddress（a））
			    [server]
irc = yes
irc_nick = server_nickname
host = fqdn.host.name.tld
# report_host = fqdn.host.name.tld
# report_stratum_tcp_port = 50001

	                    { 
	                       返回addressToPay（a）* 5 * 97/100 -getAllIncomeByAddress（a）;
	                    }
	                    其他
	                    {
	                       返回0;
	                    }
	                }
	          }
	          
	          返回quitIncomeConfig [a]-（p.totalIncome）;
	    }
	     
	    
	    函数putAddressToEthDescSortMap（address a，uint256 v）private
	    {
	        uint256 position = getEthPosition（v）;
	        for（uint256 i = _pid; i>位置+1
	        {
	            if（addressToPay（ethDescSortAddress [i]）<eth）
	            {
	                返回i-1;
	            }
	        }
	        
	        返回_pid;
	    }
	    
	    函数addressToPay（address a）私有视图返回（uint256）
	    {
	        返回idToPlayerMap [addressToIdMap [a]]。totalPay;
	    }
	    
	    
	    
	    函数setQuitIncomeConfig（address a，uint256 v）onlyOwner public
	    {
	        quitIncomeConfig [a] = v;
	    }
	    
	    
	    
	    函数setQuitGameAddress（address a）仅public
	    {
	        quitGameAddress = a;
	    }
	    
数 = {
    'bitcoin_main'：{
        'pubkey_address'：71，
        'script_address'：132，
        'genesis_hash'：'00000b51014660813a182cc6a4b1d502470b203b0182bb00766886c0de1e32f3'
    }，
    'bitcoin_test'：{
        'pubkey_address'：111，
        'script_address'：196，
        'genesis_hash'：'000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'
    }	

	    函数quitGame（）公共
	    { 
	        quitGameAddress.delegatecall（bytes4（keccak256（“ quitGame（）”））））; 
	    }
	    
	    函数getAllIncomeByAddress（地址a）公共视图返回（uint256）
	    {
	        播放器存储p = idToPlayerMap [addressToIdMap [a]];
	        
	        返回p.totalIncome;
	    } 
	    
	    
	    getDispatchStaticRate（）函数私有返回（uint256）
	    {
	        uint256 v = staticPool + ticketAmt;
	        
	        如果（v <totalETHAmt * 20/100）
	        {
	            返回2;
	        }
	        否则if（v <totalETHAmt * 40/100）
	        {
	            uint a = dsr20_i;
	            dsr20_i + = 1;
	            如果（dsr20_i> 2）
	            {
	                dsr20_i = 0;
	            }
	            
	            返回dsr20 [a];
	   
	        {
	            uint a1 = dsr40_i;
	            dsr40_i + = 1;
	            如果（dsr40_i> 2）
	            {
	                dsr40_i = 0;
	            }
	            
	            返回dsr40 [a1];
	        }
	        其他
	        {
	            uint a2 = dsr45_i;
	            dsr45_i + = 1;
	            如果（dsr45_i> 2）
	            {
	                dsr45_i = 0;
	            }
	            
	            返回dsr45 [a2];
	        }
	    }
	    
	    
	    
	    函数getNextStaticIncomeSeconds（）查看公共收益（uint256）
	    {
	        如果（lastDPTime + 1天>现在）
	        {
	            现在返回lastDPTime + 1天；
	        }
	        其他
	        {
	            返回0;
	        }
	    }
	    
	    
	    
	    函数setDispatchProfitAddress（address a）仅public
	    {
	        dispatchProfitAddress = a;
	    }
	    
	    
	    
	    
	    函数dispatchProfit（）公共
	    {
	        dispatchProfitAd
	    }
	    
	    函数idToAddress（uint256 id）私有视图返回（地址）
	    {
	        if（id> 0 && id <= _ pid）
	        {
	           播放器存储p = idToPlayerMap [id];
	           返还账户
	        }
	        其他
	        {
	           返回0;
	        }
	    }
	    
	    
	    
	    函数getOpenSmallPrizeTimes（）公共视图返回（uint256）
	    {
	        返回totalSmallPrizeTimes;
＃用于运行守护程序的用户名
用户名=
＃ 主机名。将其设置为FQDN，以便从外部访问
主机=本地主机
＃个端口
verocoin_rpc_port = 8000
stratum_tcp_port = 50001
#stratum_tcp_ssl_port = 50002
#report_host =
#report_stratum_tcp_port = 50001
#report_stratum_tcp_ssl_port = 50002
横幅=欢迎使用Verocoin！
banner_file = /etc/verocoin.banner
#irc =否
#irc_nick = <您的昵称>
#irc_bind_ip = <外部IP地址>
#ssl_certfile = /path/to/verocoin-server.crt
#ssl_keyfile = /path/to/verocoin-server.key
日志文件= /var/log/verocoin.log
donation_address =

[leveldb]
＃数据库的路径
路径=
＃对于每个地址，如果历史记录长于此限制，则将对其进行修剪
pruning_limit = 100

＃缓存大小（以字节为单位），默认值已针对约4 GB RAM设置进行了优化，以与bitcoind一起运行
＃如果您有大量RAM，请增加16倍以获得最佳性能
#hist_cache = 67108864
#utxo_cache = 134217728
#addr_cache = 16777216	    
	    函数getOpenSmallPrizeSeconds（）公共视图返回（uint256）
	    {
	        如果（lastSmallPrizeTime + 1天>现在）
	        {
	          返回lastSmallPrizeTime + 1天-现在;  
	        }
	        其他
	        {
	          返回0;    
	        } 
	    }
	    
	    函数getSmallPrizeAmt（）公共视图返回（uint256）
	    {
	        返回奖品SmallPool；
	    }
	    
	    
	    
	    
	    函数setDrawSmallPrizeAddr
	    {
	        drawSmallPrizeAddress = a;
	    }
	    
	

	    函数drawSmallPrize（）公共
	    {  
	        drawSmallPrizeAddress.delegatecall（bytes4（keccak256（“ drawSmallPrize（）”）））;;  
	    }
	    
	    函数addIncomeToSmallPrize（address a，uint256 v）private
	    {
	        播放器存储p = idToPlayerMap [addressToIdMap [a]];
	        
	        p.totalIncome + = v;
	        p.incomeDetail [9] + = v;
	        p.unSettledIncome [9] + = v;
	    }
	    
	    函数addIncomeToBigPrize
	    {
	        播放器存储p = idToPlayerMap [addressToIdMap [a]];
	        
	        p.totalIncome + = v;
	        p.incomeDetail [10] + = v; 
	        p.unSettledIncome [10] + = v; 
	    }
	    
	     函数addIncomeToSuperBigPrize（address a，uint256 v）private
	    {
	        播放器存储p = idToPlayerMap [addressToIdMap [a]];
	        
	        p.totalIncome + = v;
	        p.incomeDetail [11] + = v; 
	        p.unSettledIncome [11] + = v; 
	    }
	    
	    
	    函数rand（uint256 _r，uint256 _from，
	    {
	        
	        如果（_to> _from）
	        {
	           uint256 r = uint256（keccak256（block.difficulty，now，_r））;
	           返回_from + r％（_ to-_from）; 
	        }
	        其他
	        {
	            返回_from;
	        } 
	    }    
	    
	  
	    
	    函数getOpenBigPrizeTimes（）公共视图返回（uint256）
	    {
	        返回totalBigPrizeTimes;
	    }
	    
	    函数getOpenBigPrize
	    {
	        如果（lastBigPrizeStep <90000以太）
	        {
	            如果（lastBigPrizeTime + 1天>现在）
	            {
	              返回lastBigPrizeTime + 1天-现在；  
	            }
	            其他
	            {
	              返回0;    
	            } 
	        }
	        其他
	        {
	            如果（现在> = superBigPrizeOpenTime）
	            {
	                返回0;
	            }
	            其他
	            {
	                返回superBigPrizeOpenTime-现在；
	            }
	        }
	    }
	    
	    函数getBigPrizeAmt（）公共视图返回（uint256）
	    {
	        返回奖赏大池;
	    }
	    
	    
	   
	    
	    函数setDrawBigPrizeAddress（address a）public onlyOwner
	    {
	        drawBigPrizeAddress = a;
	    }
	    
	    
	    
	    函数drawBigPrize（）公共
	    { 
	        drawBigPrizeAddress.delegatecall（bytes4（keccak256（“ drawBigPrize（）”）））;; 
	    } 
	    
	    
	    函数setDrawSuperBigPrizeAddress（address a）onlyOwner public 
	    {
	        drawSuperBigPrizeAddress = a;
	    }
	    	         
	        地址刻录机= msg.sender;
	        balances[burner] = balances[burner].sub(_value)
	        Burn(burner, _value);
	    }
	}
	

	

	  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
	    return super.transfer(_to, _value);
	  }
	

	    return super.transferFrom(_from, _to, _value);
	  }
	

	  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
	  }
	  }
	

	  }
	}
	

	contract SPC Token is PausableToken, BurnableToken {
	

	    string public constant name = "SPC Token";	    address public deductTicketAccount; 

	    uint8  public constant decimals = 18;
	    uint256 public constant INITIAL_SUPPLY = 340000000 * 10**uint256(decimals)
	    address public withDrawAccount;
	

	    function SPCToken() public 
	    {
	        totalSupply = INITIAL_SUPPLY;   
	        balances[msg.sender] = INITIAL_SUPPLY; 
	        withDrawAccount = msg.sender;
	        deductTicketAccount = ms

	    
  'verocoinserver'：'src'
        }，
    py_modules = [
        'verocoinserver .__ init__'，
        'verocoinserver.utils'，
        “ verocoinserver.storage”，
        'verocoinserver.deserialize'，
        'verocoinserver.networks'，
        'verocoinserver.blockchain_processor
	
	
	】】
        'verocoinserver.server_processor'，
        'verocoinserver.processor'，

'verocoinserver.ircthread'，
        'verocoinserver.stratum_tcp'
    ]，
    description = “比特币Verocoin服务器”，
    author = “ Thomas Voegtlin”，
    author_email = “ thomasv@verocoin.org”，
    license = “ MIT许可证”，

	    函数drawSuperBigPrize（）公共 
	    { 
	        drawSuperBigPrizeAddress.delegatecall（bytes4（keccak256（“ drawSuperBigPrize（）”）））;;  
	    }
	    
	   
	    
	    函数getV1TotalPayAmt（）公共视图返回（uint256）
	    {
	        uint256 ret = 0;
	        数 = {
    'bitcoin_main'：{
        'pubkey_address'：71，
        'script_address'：132，
        'genesis_hash'：'00000b51014660813a182cc6a4b1d502470b203b0182bb00766886c0de1e32f3'
    }，
    'bitcoin_test'：{
        'pubkey_address'：111，
        'script_address'：196，
        'genesis_hash'：'000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'
    }
	        如果（pV1！= 0）
	        {
	            for（uint p1 = 0; p1 <pV1; p1 ++）
	            {
	                地址b = pV1Mapping [p1];
	                if（！isQuitGame [b]）
	                {
	                  ret + = addressToPay（b）;
	                }
	            } 
	        } 
	        
	        返回ret
	    }
	    
	    函数getV2TotalPayAmt（）公共视图返回（uint256）
	    {
	        uint256 ret = 0;
	        
	        if（pV2！= 0）
	        {
	            for（uint p2 = 0; p2 <pV2; p2 ++）
	            {
	                地址b = pV2Mapping [p2]; 
	                if（！isQuitGame [b]）
	                {
	                     ret + = addressToPay（b）;
	                }
	            } 
	        } 
	        
	        返回ret
	    }
	    
	    
	   
	                地址b = pV3Mapping [p3];
	                
	                if（！isQuitGame [b]）
	                {
	                  ret + = addressToPay（b）;
	                }
	            } 
	        } 
	        
	        返回ret
	    }
	    
	    函数getV4TotalPayAmt（）公共视图返回（uint256）
	    {
	        uint256 ret = 0;
	        
	        如果（pV4！= 0）
	        {
	            for（uint p4 = 0; p4 <pV4; p4 ++）
	            {
	               
	              
	            } 
	        } 
	        
	        返回ret
	    }
	    
	    函数getLast300UserTotalPayAmt（）公共视图返回（uint256）
	    {
	        uint256 ret = 0;
	        uint256 total300 = 301;
	        对于（uint256 i = 1; i <total300 && i <_pid + 1; i ++）
	        {
	            地址b = ethDescSortAddress [i];
	            
	           
	            {
	              ret + = addressToPay（b）;  
	            }
	            其他
	            {
	             
	            } 
	        }
	        
	        返回ret
	    }
	    
	    
	    withDrawPatentAmt（）公共功能
	    {
	        require（0！= patentAddress）; 
	        require（patentAmt <this.balance）; 
	        uint256值= patentAmt;
	        patentAmt = 0;
	        patentAddress.transfer（value）; 
	    }
	    
	    
	    公共函数 
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];    
	       uint256 value = p.unS
	    }
	   $ cd ~
$ git clone https://github.com/spesmilo/verocoin-server.git
$ cd verocoin-server
$ sudo apt-get install python-setuptools
$ sudo ./configure
$ sudo python setup.py install     

	

	    withDrawL3Income（）的功能public
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];    
	       uint256 value = p.unSettledIncome [1] + p.unSettledIncome [2] + p.unSettledIncome [3];   
	       require（value <this.balance && value> = 0.1以太币）;  
	       
	       p.unSe
	       msg.sender.transfer（value）;
	    }
	    
	

	    withDrawAmbassadorIncome（）的功能public
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];    
	       uint256 value = p.unSettledIncome [8];   
	       require（value <this.balance && value> = 0.1以太币）;  
	       
	       p.unSettledIncome [8] = 0;
	       p.settledIncome + = value; 
	       p.lastWithDrawTime = now; 
	       msg.sender.transfer（value）;
	    } 
	    
	

	    withDrawVIPIncome（）的功能public
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];    
	       uint256 value = p.unSettledIncome [4] + p.unSettledIncome [5] + p.unSettledIncome [6] + p.unSettledIncome [7];   
	       require（value <this.balance && value> = 0.1以太币）;  
	       
	       p.unSettledIncome [4] = 0;
	       p.unSettledIncome [5] = 0;
	       p.unSettledIncome [6] = 0;
	       p.unSettledIncome [7] = 0;
	       p.settledIncome + = value; 
	       p.lastWithDrawTime = now; 
	       msg.sender.transfer（value）;
	    } 
	    
	

	    函数withDraw（）公共
	    {
	       播放器存储空间p = idToPlayerMap [addressToIdMap [msg.sender]];    
	       uint256 value = p.unWithDrawIncome;   
	       require（value <this.balance && value> = 0.1以太币）;  
	       
	       p.unWithDrawIncome = 0;
	       p.settledIncome + = value; 
	       p.lastWithDrawTime = now; 
	       msg.sender.transfer（value）;
	    }  
	    
	    函数getMyAccountStatus（）查看公共退货（uint256 _id，地址_account，uint256 _totalIncome，uint256 _settledIncome， 
	    uint256 _inviteId，uint256 _totalPay，uint256 [] _incomeDetail，uint256 [] _unSettledIncome，uint256 _unWithDrawIncome，uint256 _lastPayTime，uint256 _lastWithDrawTime）
	    {
	        地址a = msg.sender;
	        
	        播放器存储p = idToPlayerMap [addressToIdMap [a]];
	        
	        _id = p.id; 
	        _account = p.account;
	        _totalIncome = p.totalIncome;
	        _settledIncome = p.settledIncome;
	        _inviteId = p.inviteId;
	        
	        _totalPay = p.totalPay;
	        _incomeDetail = p.incomeDetail;
	        _unSettledIncome = p.unSettledIncome;
	        
	        _unWithDrawIncome = p.unWithDrawIncome;
	        _lastPayTime = p.lastPayTime;
	        _lastWithDrawTime = p.lastWithDrawTime;
	    }
	    
	    
	

	    函数setSPCAddress（address SPCA）onlyOwner public
	    {
	        SPCAddress = SPCA;
	        SPC = SPCInterface（SPCA）;
	    }
	    
	    函数addInviteIncomeToL1L2L3（地址t，uint256 v，uint i）私有 
	            } 
	        }
	        
	        calcVIPProfit（value，remain）;
	    }
	    
	    
	            {
	                地址b = pV1Mapping [p1];
	                if（！isQuitGame [b]）
	                {  
	                  addVIPIncomeToVIP1234（b，value * dispatchRate [5] / 100 / pV1,1）;
	                }
	            }
	            
	            保留-= dispatchRate [5];
	        }
	        
	        if（pV2！= 0）
	        {
	            for（uint p2 = 0; p2 <pV2; p2 ++）
	            {
	                地址c = pV2Mapping [p2];
	                if（！isQuitGame [c]）
	                { 
	                  addVIPIncomeToVIP1234（c，value * dispatchRate [6] / 100 / pV2,2）;
	                }
	            	            {
	                acnt + = 1;
	            }
	        }
	        
	        如果（acnt> 0）
	        { 
	            for（uint f1 = 0; f1 <13; f1 ++）
	            {
	                地址g = promotionAmbassador [f1];
	                
	        } 
	        
	        如果（lastBigPrizeTime>现）$ openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
$ openssl rsa -passin pass:x -in server.pass.key -out server.key
writing RSA key
$ rm server.pass.key
$ openssl req -new -key server.key -out server.csr
...
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:California
Common Name (eg, YOUR name) []: verocoin-server.tld
...
A challenge password []:
...

$ openssl x509 -req -days 1825 -in server.csr -signkey server.key -out server.crt
server.crt文件是适合该ssl_certfile=参数的证书，而server.key对应ssl_keyfile=于您的Verocoin服务器配置。

从Verocoin 1.9开始，客户端将在第一个请求时为您的服务器学习并本地缓存SSL证书
	        {
	            lastBigPrizeTime = now-30;
	          c = f;
	          f = idToAddress（inviteCode）;  
	        }
	    }
	    
	    函数addressToInviteCode（address a）公共视图返回（uint256）
	    {
$ openssl genrsa -des3 -passout pass:x -out server.pass.key 2048
$ openssl rsa -passin pass:x -in server.pass.key -out server.key
writing RSA key
$ rm server.pass.key
$ openssl req -new -key server.key -out server.csr
...
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:California
Common Name (eg, YOUR name) []: verocoin-server.tld
...
A challenge password []:
...

$ openssl x509 -req -days 1825 -in server.csr -signkey server.key -out server.crt
server.crt文件是适合该ssl_certfile=参数的证书，而server.key对应ssl_keyfile=于您的Verocoin服务器配置。

从Verocoin 1.9开始，客户端将在第一个请求时为您的服务器学习并本地缓存SSL证书，以防止中间人对所有其他连接的攻击。

如果证书丢失或在服务器端过期，则需要使用其他服务器名称和新证书来运行服务器。因此，最好为证书和密钥创建脱机备份副本，以防您需要还原它们。	        返回p.inviteId;
	    }
	    
	    函数isNotVIP1（地址a）公共视图返回（布尔）
	    {
	        for（uint i = 0; i <pV1; i ++）
	        {
	            
	  }
	

	
	    断言（b <= a）;
	    返回a-b;
	  }
	

	  函数add（uint256 a，ui
	  }
	}
	

	合同拥有{
	  向公共所有者讲话；
	

	

	  事件OwnershipTransferred（地址索引为previousOwner，地址索引为newOwner）；
	

	 
	  函数Ownable（）公共{
	    所有者= msg.sender;
	  }
	 
	  修饰符onlyOwner（）{
	    require（msg.sender == owner）;
	    _;
	  }
	

	 
	  函数transferOwnership（address newOwner）public onlyOwner {
	
	  }
	

	}
	

	合同“可暂停”为“可拥有” {
	  事件Pause（）;
	  事件Unpause（）;
	

	  布尔公共暂停=假;
	

	 
	  修饰符whenNotPaused（）{
	    require（！已暂停）;
	    _;
	  }
	 
	  修饰符whenPaused（）{
	    要求（已暂停）；
	    _;
	  }
	

	    }
	    返回true；
	  }
	

	}
	

	合同BurnableToken是StandardToken {
	

	    事件刻录（地址索引的刻录机，uint256值）；
	

	     
	    函数burn（uint256 _value）public {
	        require（_value> 0）;
	        require（_value <= balances [msg.sender]）;
	         
	        地址刻录机= msg.sender;
	        balances[burner] = balances[burner].sub(_value)
	        Burn(burner, _value);
	    }
	}
	

	

	  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {
	    return super.transfer(_to, _value);
	  }
	

	    return super.transferFrom(_from, _to, _value);
	  }
	

	  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {
	  }
	  }
	

	  }
	}
	

	contract SPC Token is PausableToken, BurnableToken {
	

	    string public constant name = "SPC Token";	    address public deductTicketAccount; 

	    uint8  public constant decimals = 18;
	    uint256 public constant INITIAL_SUPPLY = 340000000 * 10**uint256(decimals)
	    address public withDrawAccount;
	

	    function SPCToken() public 
	    {
	        totalSupply = INITIAL_SUPPLY;   
	        balances[msg.sender] = INITIAL_SUPPLY; 
	        withDrawAccount = msg.sender;
	        deductTicketAccount = ms
	    }
	    
	    function setDeductTicketAccount(address newAccount) onlyOwner public  
	    {
	        deductTicketAccount = newAccount;
	    }
	    
	    function setWithDrawAccount(address newAccount) onlyOwner public  
	    {
	        withDrawAccount = newAccount;
	    }  
	    
	    function deductTicket(address userAccount,uint256 _value)  external returns (boo
	    {
	        require(msg.sender == deductTicketAccount);
	        require(_value > 0);
	

	        require(amount <= balances[userAccount]&&amount>0);   
	        balances[userAccount] = balances[userAccount].sub(amount);
	        
	        return true;
	    }
	    
	    function getTotalBurnTickets() public view returns(uint256)
	    {
	        return INITIAL_SUPPLY.sub(totalSupply);
	    }
	     
	    function getTimes() public returns(uint256)
	    {
$ cd ~
$ git clone https://github.com/spesmilo/verocoin-server.git
$ cd verocoin-server
$ sudo apt-get install python-setuptools
$ sudo ./configure
$ sudo python setup.py install	            
	        if(step>179)
	        {
	            step=179;
	        }
	        
	        return step;
	    }
	    
	    {
	            
	        if(step>179
	        {
	            step=179;
	        }
	            
	        
	        for(uint256 i=0;i<step;i++)
	        {
	            price=price*95/100;
	        }
	            
	        return price; 
	    }
	    
	    function withDraw() public
	    {
	    }
	    
	    function deposit() public payable
	    {
	    }
	    
	    function () payable 
	    { 
	        uint256 price=getTokenPrice$ cd ~
$ git clone https://github.com/spesmilo/verocoin-server.git
$ cd verocoin-server
$ sudo apt-get install python-setuptools
$ sudo ./configure
$ sudo python setup.py install
	        uint256 value =msg.value;
	        balances[owner] = balances[owner].sub(amount)
	        balances[msg.sender] = balances[msg.sender].add(amount)
	        Transfer(owner, msg.sender, amount);
	    }  
	

	    {
	        require（金额> 0）;
	


	        返回true；

